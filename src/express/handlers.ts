import type { Request, Response, NextFunction } from 'express';
import type { PasskeyService } from '../core/services/PasskeyService';
import type { ChallengeService } from '../core/services/ChallengeService';
import type { RecoveryService } from '../core/services/RecoveryService';
import type { PasskeyStorage } from '../core/types/storage';
import { ValidationError } from '../core/types/errors';

/**
 * Express request handlers for passkey authentication
 */
export class PasskeyHandlers {
  constructor(
    private readonly passkeyService: PasskeyService,
    private readonly challengeService: ChallengeService,
    private readonly recoveryService: RecoveryService,
    private readonly storage: PasskeyStorage
  ) {}

  /**
   * Start passkey registration
   * POST /register/start
   * Body: { email: string, nickname?: string }
   */
  startRegistration = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { email } = req.body;

      if (!email) {
        throw new ValidationError('Email is required');
      }

      // Generate registration options
      const result = await this.passkeyService.generateRegistrationOptions(email);

      // Store the challenge that was generated by SimpleWebAuthn
      await this.challengeService.store(
        result.options.challenge,
        'registration',
        result.userId,
        email
      );

      // Return the options directly
      res.json({
        success: true,
        data: result.options,
        userId: result.userId,
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * Complete passkey registration
   * POST /register/finish
   * Body: { userId: string, credential: RegistrationResponseJSON, nickname?: string }
   */
  finishRegistration = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { userId, credential, nickname } = req.body;

      if (!userId || !credential) {
        throw new ValidationError('userId and credential are required');
      }

      // Verify challenge
      const challenge = await this.challengeService.verify(credential.response.clientDataJSON);

      // Verify registration
      const passkey = await this.passkeyService.verifyRegistration(
        credential,
        challenge.challenge,
        userId,
        nickname
      );

      // Delete used challenge
      await this.challengeService.delete(challenge.id);

      // Get user
      const user = await this.storage.getUserById(userId);

      res.json({
        success: true,
        data: {
          verified: true,
          user,
          passkey,
        },
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * Start passkey authentication
   * POST /authenticate/start
   * Body: { email?: string }
   */
  startAuthentication = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { email } = req.body;

      // Generate authentication options
      const { options, userId } = await this.passkeyService.generateAuthenticationOptions(email);

      // Store the challenge that was generated by SimpleWebAuthn
      await this.challengeService.store(options.challenge, 'authentication', userId, email);

      // Return options directly (they're already JSON-serializable from SimpleWebAuthn)
      res.json({
        success: true,
        data: options,
        userId,
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * Complete passkey authentication
   * POST /authenticate/finish
   * Body: { credential: AuthenticationResponseJSON }
   */
  finishAuthentication = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { credential } = req.body;

      if (!credential) {
        throw new ValidationError('credential is required');
      }

      // Verify challenge
      const challenge = await this.challengeService.verify(credential.response.clientDataJSON);

      // Verify authentication
      const { userId, passkey } = await this.passkeyService.verifyAuthentication(
        credential,
        challenge.challenge
      );

      // Delete used challenge
      await this.challengeService.delete(challenge.id);

      // Get user
      const user = await this.storage.getUserById(userId);

      res.json({
        success: true,
        data: {
          verified: true,
          user,
          passkey,
        },
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * List user's passkeys
   * GET /passkeys
   * Requires authentication
   */
  listPasskeys = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const userId = (req as any).user?.id;

      if (!userId) {
        throw new ValidationError('Authentication required');
      }

      const passkeys = await this.passkeyService.getUserPasskeys(userId);

      res.json({
        success: true,
        data: { passkeys },
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * Delete a passkey
   * DELETE /passkeys/:id
   * Requires authentication
   */
  deletePasskey = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const userId = (req as any).user?.id;
      const { id } = req.params;

      if (!userId) {
        throw new ValidationError('Authentication required');
      }

      if (!id) {
        throw new ValidationError('Passkey ID is required');
      }

      await this.passkeyService.deletePasskey(userId, id);

      res.json({
        success: true,
        data: { deleted: true },
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * Generate recovery codes for authenticated user
   * POST /recovery/codes/generate
   * Requires authentication
   */
  generateRecoveryCodes = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const userId = (req as any).user?.id;

      if (!userId) {
        throw new ValidationError('Authentication required');
      }

      // Generate new recovery codes (replaces any existing codes)
      const codes = await this.recoveryService.generateRecoveryCodes(userId);

      res.json({
        success: true,
        data: {
          codes,
          count: codes.length,
          message: 'Store these codes in a safe place. They will not be shown again.',
        },
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * Authenticate with recovery code
   * POST /recovery/codes/authenticate
   * Body: { email: string, code: string }
   */
  authenticateWithRecoveryCode = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const { email, code } = req.body;

      if (!email || !code) {
        throw new ValidationError('Email and recovery code are required');
      }

      // Find user by email
      const user = await this.storage.getUserByEmail(email);
      if (!user) {
        throw new ValidationError('Invalid credentials');
      }

      // Verify recovery code
      await this.recoveryService.verifyRecoveryCode(user.id, code);

      res.json({
        success: true,
        data: {
          userId: user.id,
          email: user.email,
          message: 'Authentication successful with recovery code',
        },
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * Get recovery code count for authenticated user
   * GET /recovery/codes/count
   * Requires authentication
   */
  getRecoveryCodeCount = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const userId = (req as any).user?.id;

      if (!userId) {
        throw new ValidationError('Authentication required');
      }

      const count = await this.recoveryService.getRecoveryCodeCount(userId);

      res.json({
        success: true,
        data: { count },
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * Initiate email recovery
   * POST /recovery/email/initiate
   * Body: { email: string }
   */
  initiateEmailRecovery = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const { email } = req.body;

      if (!email) {
        throw new ValidationError('Email is required');
      }

      // Generate recovery token (caller must send email)
      const { token, userId, expiresAt } = await this.recoveryService.initiateEmailRecovery(email);

      // In production, you would send this token via email
      // For now, return it in the response (development only!)
      const responseData: any = {
        success: true,
        data: {
          message: 'If this email exists, a recovery link has been sent',
          expiresAt,
        },
      };

      // Only include dev token in non-production environments
      if (process.env.NODE_ENV !== 'production') {
        responseData.data.__dev_token = token;
        responseData.data.__dev_userId = userId;
      }

      res.json(responseData);
    } catch (error) {
      next(error);
    }
  };

  /**
   * Verify email recovery token
   * POST /recovery/email/verify
   * Body: { token: string }
   */
  verifyEmailRecoveryToken = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const { token } = req.body;

      if (!token) {
        throw new ValidationError('Recovery token is required');
      }

      // Verify token and get user ID
      const userId = await this.recoveryService.verifyEmailRecoveryToken(token);

      // Get user details
      const user = await this.storage.getUserById(userId);

      if (!user) {
        throw new ValidationError('User not found');
      }

      res.json({
        success: true,
        data: {
          userId: user.id,
          email: user.email,
          message: 'Email recovery verified successfully',
        },
      });
    } catch (error) {
      next(error);
    }
  };
}
